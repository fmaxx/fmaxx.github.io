---
layout:     post
title:      Kotlin, как работает SUSPEND под капотом.
date:       2021-10-10 12:02:00
summary:    Разбираемся, что происходит при использовании ключевого слова SUSPEND в Kotlin.
categories: Android Kotlin Coroutines Suspend
---

Перевод статьи [The suspend modifier — under the hood](https://manuelvivo.dev/suspend-modifier){:target="_blank"}.


Как компилятор преобразует _suspend_ код, чтобы корутины можно было приостанавливать и возобновлять?

Корутины в Kotlin представлены ключевым словом **_suspend_**. Интересно что там происходит внутри? Как компилятор трансформирует _suspend_ блоки в код, который поддерживающий приостановку и возобновление работы корутины?

Знание этого поможет понимать почему suspend функция не возвращает управление, пока не завершится вся запущенная работа и как код может приостановить выполнение без блокировки потоков. 

> TL;DR; Компилятор Kotlin создает специальную машину состояний для каждой suspend функции, эта машина берет управление корутиной на себя!

Новенький в Android? Взгляни на эти полезные ресурсы по корутинам:
- [Using coroutines in your Android app](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0){:target="_blank"}.
- [Advanced Coroutines with Kotlin Flow and Live Data](https://developer.android.com/codelabs/advanced-kotlin-coroutines#0){:target="_blank"}.

Для тех, кто предпочитает видео:

<iframe width="840" height="473" src="https://www.youtube.com/embed/IQf-vtIC-Uc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# Корутины, краткое введение
Говоря по-простому, корутины это асинхронные операции в Android. Как описано в [документации](https://developer.android.com/kotlin/coroutines){:target="_blank"}, мы можем использовать корутины для управления асинхронными задачами, которые иначе блокируют основной поток и приводят к зависанию UI приложения.

Также корутины удобно использовать для замены callback-кода на имеративный код. Например, посмотрите на этот код с использованием колбеков:
```kotlin
// Simplified code that only considers the happy path
fun loginUser(userId: String, password: String, userResult: Callback<User>) {
  // Async callbacks
  userRemoteDataSource.logUserIn { user ->
    // Successful network request
    userLocalDataSource.logUserIn(user) { userDb ->
      // Result saved in DB
      userResult.success(userDb)
    }
  }
}
```

Заменяем эти колбекина последовательные вызовы функций с использованием корутин:
```kotlin
suspend fun loginUser(userId: String, password: String): User {
  val user = userRemoteDataSource.logUserIn(userId, password)
  val userDb = userLocalDataSource.logUserIn(user)
  return userDb
}
```
Для функций, которые вызываются в корутинах, мы добавили ключевое слово **suspend**. Так компилятор знает, что эти функции для корутин. С точки зрения разработчика, рассматривайте suspend функцию как обычную, выполнение которой может быть приостановлено и возобновлено в определенный момент.

В отличие от колбеков, корутины предлагают простой способ переключения между потоками и обработки исключений.

Но что в действительности делает компилятор внутри, когда мы отмечаем функцию как _suspend_?

## Suspend под капотом
Давайте вернемся к suspend функции `loginUser`, посмотрите, другие функции которые она вызывает являются также suspend функциями:

```kotlin
suspend fun loginUser(userId: String, password: String): User {
  val user = userRemoteDataSource.logUserIn(userId, password)
  val userDb = userLocalDataSource.logUserIn(user)
  return userDb
}

// UserRemoteDataSource.kt
suspend fun logUserIn(userId: String, password: String): User

// UserLocalDataSource.kt
suspend fun logUserIn(userId: String): UserDb
```

Кратко говоря, компилятор Kotlin берет suspend функции и преобразовывает их в оптимизированную версию колбеков с использованием [конечной машины состояний](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} (о которой мы поговорим позже).

# Интерфейс Continuation
Suspend функции взаимодействуют друг с другом с помощью `Continuation` объектов. `Continuation` объект - это просто generic интерфейс-колбек с дополнительными данными. Позже мы увидим, реализация интерфейса будет представлять собой сгенерированную машину состояний для suspend функции.

Сам интерфейс выглядит так:
```kotlin
interface Continuation<in T> {
  public val context: CoroutineContext
  public fun resumeWith(value: Result<T>)
}
```
- `context` это экземпляр `CoroutineContext`, который будет использоваться в этом продолжении.
- `resumeWith` возобновляет выполнение корутины с [Result](https://github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/Result.kt){:target="_blank"}, он может либо содержать результат вычисления, либо исключение.

> С Kotlin 1.3 и далее, вы можете использовать extensions функции [resume(value: T)](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume.html){:target="_blank"} и [resumeWithException(exception: Throwable)](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume-with-exception.html){:target="_blank"}, это специализированные версии метода `resumeWith`.

Компилятор заменяет ключевое слово suspend на дополнительный аргумент `completion` (тип `Continuation`) в сигнатуре функции, который будет использоваться для передачи результата работы suspend функции в вызывающую корутину:

```kotlin
fun loginUser(userId: String, password: String, completion: Continuation<Any?>) {
  val user = userRemoteDataSource.logUserIn(userId, password)
  val userDb = userLocalDataSource.logUserIn(user)
  completion.resume(userDb)
}
```
Для упрощения, наш пример возвращает `Unit` вместо объекта `User`.

Байткод suspend функций фактически возвращает `Any?` так как это объединение (union) типов `T | COROUTINE_SUSPENDED`. Что позволяет функции возвращать результат синхронно, когда это возможно.

> Если suspend функция не вызывает другие suspend функции, компилятор добавляет добавляет аргумент Continuation, но не будет с ним ничего делать, байткод функции будет выглядеть как обычная функция.

Кроме того, интерфейс `Continuation` можно увидеть в:

- При конвертации колбек-API в коротины с использованием [suspendCoroutine](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html){:target="_blank"} или [suspendCancellableCoroutine](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html){:target="_blank"} (предпочтительнее использовать в большинстве случаев). Вы напрямую взаимодействуете с 
экземпляром `Continuation`, чтобы возобновить корутину, приостановленную после выполнения блока кода из аргументов suspend функции.

- Вы можете запустить корутину при помощи [startCoroutine](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html){:target="_blank"} extension функции в suspend методе. Она принимает `Continuation` как аргумент, который будет вызван, когда новая корутина завершится либо с результатом, либо с исключением.

# Используем Dispatchers
Вы можете переключаться между разными диспетчерами для запуска вычислений на разных потоках. Как Kotlin знает, где возобновить suspend вычисления?

Есть подтип `Continuation`, он называется [DispatchedContinuation](https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt){:target="_blank"}, где его метод `resume` делает вызов `Dispatcher` доступного в контексте корутины `CoroutineContext`. Все диспетчеры (`Dispatchers`) будут вызывать метод `dispatch`, кроме типа `Dispatchers.Unconfined`, он переопределяет метод `isDispatchNeeded` (он вызывается перед вызовом `dispatch`), который возвращает _false_ в этом случае.

## Сгенрированная машина состояний

> Уточнение: Приведенный код не полностью соответствует байткоду сгенерированному компилятором. Это будет код на Kotlin, достаточно точный, для понимания того, что в действительности происходит внутри. Это представление сгенерировано корутинами версии 1.3.3 и может поменяться в следующих версиях библиотеки.

Компилятор Kotlin определяет, когда функция может остановится внутри. Каждая точка останова представляется как отдельное состояние в конечной машине состояний. Такие состояния компилятор помечает метками:

```kotlin
fun loginUser(userId: String, password: String, completion: Continuation<Any?>) {
  
  // Label 0 -> first execution
  val user = userRemoteDataSource.logUserIn(userId, password)
  
  // Label 1 -> resumes from userRemoteDataSource
  val userDb = userLocalDataSource.logUserIn(user)
  
  // Label 2 -> resumes from userLocalDataSource
  completion.resume(userDb)
}
```

Компилятор использует `when` для состояний:

```kotlin
fun loginUser(userId: String, password: String, completion: Continuation<Any?>) {
  when(label) {
    0 -> { // Label 0 -> first execution
        userRemoteDataSource.logUserIn(userId, password)
    }
    1 -> { // Label 1 -> resumes from userRemoteDataSource
        userLocalDataSource.logUserIn(user)
    }
    2 -> { // Label 2 -> resumes from userLocalDataSource
        completion.resume(userDb)
    }
    else -> throw IllegalStateException(/* ... */)
  }
}
```

Этот код неполный, так как различные состояния не могут обмениваться информацией. Компилятор использует для обмена тот же самый объект `Continuation`. Вот почему родительски тип в `Continuation` это `Any?` вместо ожидаемого возвращаемого типа `User`.

При этом компилятор создает приватный класс, который:
1. хранит нужные данные
2. вызывает функцию `loginUser` рекурсивно для возобновления вычисления

Ниже представлен примерный вид такого сгенерированного класса:
> Комментарии в коде были добавлены вручную для объяснения действий

```kotlin
fun loginUser(userId: String?, password: String?, completion: Continuation<Any?>) {
  
  class LoginUserStateMachine(
    // completion parameter is the callback to the function 
    // that called loginUser
    completion: Continuation<Any?>
  ): CoroutineImpl(completion) {
  
    // Local variables of the suspend function
    var user: User? = null
    var userDb: UserDb? = null
  
    // Common objects for all CoroutineImpls
    var result: Any? = null
    var label: Int = 0
  
    // this function calls the loginUser again to trigger the
    // state machine (label will be already in the next state) and
    // result will be the result of the previous state's computation
    override fun invokeSuspend(result: Any?) {
      this.result = result
      loginUser(null, null, this)
    }
  }
  /* ... */
}
```

Поскольку `invokeSuspend` вызывает `loginUser` снова только с аргументом `Continuation`, остальные аргументы в функции `loginUser` будут нулевыми. На этом этапе компилятору нужно только добавить информацию как переходить из одного состояния в другое.

Компилятору нужно знать:
1. Функция вызывается первый раз или
2. Функция была возобновлена из предыдущего состояния
Для этого проверяется тип аргумента `Continuation` в функции:

```kotlin
fun loginUser(userId: String?, password: String?, completion: Continuation<Any?>) {
  /* ... */
  val continuation = completion as? LoginUserStateMachine ?: LoginUserStateMachine(completion)
  /* ... */
}
```

Если функция вызывается первый раз, то создается новый экземпляр `LoginUserStateMachine` и аргумент `completion` передается в этот экземпляр, чтобы возобновить вычисление. Иначе продолжится выполнение машины состояний.

Давайте взглянем на код, который генерирует компилятор для смены состояний и обмена информацией между ними:

































